🏎️ 더 나은 성능을 위한 class VS sturct
기본적으로 struct는 class에 비해 메모리에 할당 / 할당 해제가 빠릅니다. 하지만, 지금처럼 값 타입인 Queue 안에 참조 타입인 Node가 들어있는 구조라면 오히려 struct를 선택한것이 더 느려질 수 있습니다. 이전 학습활동때 봤던 WWDC에 비슷한 내용이 있었네요!

struct Queue의 경우
무제 20
class Queue의 경우
무제 5
해당 키노트의 예제처럼 표현해 보았습니다. Queue가 스택에 생성되지만 front와 rear가 참조타입이기 때문에 두 개의 프로퍼티의 원본값은 Heap에 저장이됩니다.

이렇게 2개 이상의 레퍼런스가 있을 경우, struct는 class보다 더 많은 reference counting을 하므로, reference counting overhead 가 발생하게 됩니다. 또한 Queue의 인스턴스가 복사될 때 레퍼런스도 함께 복사되면서 값타입을 사용하는 의미도 퇴색됩니다.

여기에서 LinkedList와 Queue가 class로 구현되야 하는 이유가 또 생긴 것 같습니다..!

🧐🧐 mutating이란 무엇일까요?
우선 제가 대략적으로 알고있던mutating은 ‘변경할 수 없는 struct의 프로퍼티를 메서드가 변경 할 수 있게 만들어 주는 키워드’ 정도로 이해하고 있었습니다.

많은 설명에 struct는 불변 하다는 것이 대전제로 보였습니다. 왜 불변할까요? 값타입 이라서 라고 합니다.값타입은 왜 불변해야 하죠? 값 타입은 기본적으로 스택영역에 저장되는데, 메모리상 스택영역의 크기는 컴파일 타임에 결정되어 고정적 이기 때문일까요? (저는 이렇게 이해했습니다.)

하지만 저에게는 struct는 변경이 가능한 것처럼 보여서 조금 혼란이 있었습니다..


아주 단순한 예시입니다. 불변하다는 struct의 프로퍼티가 외부에서는 클래스와 같이 잘만 바뀌고 있는 것으로 보입니다..

어짜피 바뀔수 있는 것이라면.. 내부 메서드를 통해 바뀔때는 왜 굳이 mutating을 써줘야 하는 걸까요? mutating의 정확한 역할은 무엇이고 대체 무엇이 불변 하다는 것일까요??

👀 결론!!
결론부터 말하면 값타입은 그자체로 불변 한것이 맞습니다. 값타입의 수정이 일어나면, 그것이 내부 메서드를 통해서든, 외부에서의 접근이든 상관없이 해당 인스턴스는 새로운 인스턴스로 교체된다고 합니다.

image

이해를 돕기위해 class내부의 참조타입과 값타입이 바뀔 때 속성감시자의 동작 유무를 테스트 해보았습니다.

실행 결과 왼쪽 참조타입인 name 은 속성감시자가 실행되지 않았고, 오른쪽 값타입인 name 은 정상적으로 실행 되는걸 확인 할 수 있었습니다.

참조타입 name 은 내부의 값이 바뀌어도 레퍼런스가 바뀌지 않았기 때문에 속성감시자가 실행되지 않은 것이고, 이것은 프로퍼티의 값이 실제로 수정 되었다고 볼 수 있습니다.
반면에 값타입 name 은 name의 내부 값이 바뀌기 위해 새로운 인스턴스가 내부에 생성되며 교체되기 때문에 속성감시자가 실행 되었습니다. 이것은 값타입 자체가 수정된 것이 아니라 새로운 인스턴스로 교체된 것입니다.
변경된 것이 아니라 교체된 것이었다..!
struct는 인스턴스를 let 으로 선언하면 immutable, var로 선언하면 mutable 하게 보이지만 여기서 mutable 하다는 것은 래퍼런스 타입처럼 실제 내부의 값을 변경할수 있는 타입이 된다는 의미가 아닙니다. 인스턴스의 재생성 및 교체가 가능해진다는 의미입니다.

메서드에 mutating 을 추가하는 것은 이 메서드를 호출했을 때 이런 인스턴스의 재생성 및 교체가 트리거 된다는 것을 개발자/API에 선언하는 것입니다.

immutable한 메서드가 기본값인 이유

mutating value들은 미래의 상태를 예측하기가 매우 어렵고 이 때문에 여러 bug를 야기할 수 있기 때문입니다.

돌고돌아서 해주신 질문에 답을 할 준비가 된 것 같습니다..

mutating이란 무엇이고 현재 왜 필요한가요?

mutating은 자신의 프로퍼티 값을 변경할수 없게 되어있는 struct 메서드의 기본값을 해당 메서드를 호출했을 때 인스턴스의 재생성 및 교체가 가능하도록 만드는 키워드 입니다. 현재는 sturct로 queue를 구현해서 자연스럽게 사용했습니다.

반복적으로 mutating이 일어나야한다면 Qeueu는 class로 구현되는 것이 좀 더 좋은 퍼포먼스를 낼 수 있지 않을까요?

맞습니다. 현재 queue의 구조는 RC 오버헤드가 일어나게 되어있어 성능상 불이익이 있을 뿐만 아니라 반복적으로 mutating이 일어나는 것도 메모리의 재할당이 일어나기 때문에 (정확히 맞는지는 모르겠습니다) class로 구현해 해결하는 것이 좋아 보입니다!

mutating 키워드에 대해 알아보다 꼬리를 무는 의문에 많은 공부를 하게되었네요..좀 길긴 하지만 정리하는 겸 적어보았습니다. 감사합니다..!!!

아직 헷갈리는 부분도 많아서 틀리거나 잘못 이해한 부분이 있다면 지적 부탁드립니다 ㅎㅎ